#
#        1         2         3         4         5         6         7         8
# 345678901234567890123456789012345678901234567890123456789012345678901234567890
#

from stonegentool import \
EatToken,SplitListOfTypes,ParseTemplateType,ProcessSchema, \
CheckSchemaSchema,LoadSchema,trim,ComputeRequiredDeclarationOrder, \
GetTemplatingDictFromSchemaFilename
import unittest
import os
import re
import pprint
from jinja2 import Template

ymlSchema = trim("""rootName: VsolMessages

struct B:
  someAs: vector<A>
  someInts: vector<int32>

struct C:
  someBs: vector<B>
  ddd:    vector<string>

struct A:
  someStrings: vector<string>
  someInts2: vector<int32>
  movies: vector<MovieType>

enum MovieType:
  - RomCom
  - Horror
  - ScienceFiction
  - Vegetables

enum CrispType:
 - SaltAndPepper
 - CreamAndChives
 - Paprika
 - Barbecue
)
""")

def RemoveDateTimeLine(s : str):
  # regex are non-multiline by default, and $ does NOT match the end of the line
  s2 = re.sub(r"^// autogenerated by stonegentool on .*\n","",s)
  return s2

class TestStonegentool(unittest.TestCase):
  def test_EatToken_empty(self):
    c = r""
    a,b = EatToken(c)
    self.assertEqual(a,r"")
    self.assertEqual(b,r"")

  def test_EatToken_simpleNonTemplate(self):
    c = r"int32"
    a,b = EatToken(c)
    self.assertEqual(a,r"int32")
    self.assertEqual(b,r"")

  def test_EatToken_simpleTemplate(self):
    c = r"vector<string>"
    a,b = EatToken(c)
    self.assertEqual(a,r"vector<string>")
    self.assertEqual(b,r"")

  def test_EatToken_complexTemplate(self):
    c = r"vector<map<int64,string>>,vector<map<int32,string>>"
    a,b = EatToken(c)
    self.assertEqual(a,r"vector<map<int64,string>>")
    self.assertEqual(b,r"vector<map<int32,string>>")

  def test_EatToken_complexTemplates(self):
    c = r"vector<map<vector<string>,map<int32,string>>>,map<int32,string>,map<map<int32,string>,string>"
    a,b = EatToken(c)
    self.assertEqual(a,r"vector<map<vector<string>,map<int32,string>>>")
    self.assertEqual(b,r"map<int32,string>,map<map<int32,string>,string>")
    a,b = EatToken(b)
    self.assertEqual(a,r"map<int32,string>")
    self.assertEqual(b,r"map<map<int32,string>,string>")

  def test_SplitListOfTypes(self):
    c = r"vector<map<vector<string>,map<int32,string>>>,map<int32,string>,map<map<int32,string>,string>"
    lot = SplitListOfTypes(c)
    self.assertEqual(3,len(lot))
    self.assertEqual("vector<map<vector<string>,map<int32,string>>>",lot[0])
    self.assertEqual("map<int32,string>",lot[1])
    self.assertEqual("map<map<int32,string>,string>",lot[2])

  def test_SplitListOfTypes_bogus(self):
    c = r"vector<map<vector<string>,map<int32,string>>,map<int32,string>,map<map<int32,string>,string"
    self.assertRaises(Exception,SplitListOfTypes,c) # the argument c must be passed to assertRaises, not as a normal call of SplitListOfTypes
    
  def test_ParseTemplateType_true(self):
    c = "map<vector<map<int,vector<string>>>,map<vector<int>,vector<string>>>"
    (ok,a,b) = ParseTemplateType(c)
    self.assertEqual(ok,True)
    self.assertEqual(a,"map")
    self.assertEqual(b,["vector<map<int,vector<string>>>","map<vector<int>,vector<string>>"])

    (ok2,a2,b2) = ParseTemplateType(b[0])
    self.assertEqual(ok2,True)
    self.assertEqual(a2,"vector")
    self.assertEqual(b2,["map<int,vector<string>>"])

    (ok3,a3,b3) = ParseTemplateType(b[1])
    self.assertEqual(ok3,True)
    self.assertEqual(a3,"map")
    self.assertEqual(b3,["vector<int>","vector<string>"])

    (ok4,a4,b4) = ParseTemplateType(b2[0])
    self.assertEqual(ok4,True)
    self.assertEqual(a4,"map")
    self.assertEqual(b4,["int","vector<string>"])
    
  def test_ParseSchema(self):
    fn = os.path.join(os.path.dirname(__file__), 'test_data', 'test1.yaml')
    obj = LoadSchema(fn)
    # we're happy if it does not crash :)
    CheckSchemaSchema(obj)

  # def test_ParseSchema_bogus_json(self):
  #   fn = os.path.join(os.path.dirname(__file__), 'test', 'test1_bogus_json.jsonc')
  #   self.assertRaises(Exception,LoadSchema,fn)

  # def test_ParseSchema_bogus_schema(self):
  #   fn = os.path.join(os.path.dirname(__file__), 'test', 'test1_bogus_schema.jsonc')
  #   obj = LoadSchema(fn)
  #   self.assertRaises(Exception,CheckSchemaSchema,obj) 

  def test_ComputeRequiredDeclarationOrder(self):
    fn = os.path.join(os.path.dirname(__file__), 'test_data', 'test1.yaml')
    obj = LoadSchema(fn)
    genOrder: str = ComputeRequiredDeclarationOrder(obj)
    self.assertEqual(3,len(genOrder))
    self.assertEqual("A",genOrder[0])
    self.assertEqual("B",genOrder[1])
    self.assertEqual("C",genOrder[2])

  # def test_GeneratePreambleEnumerationAndStructs(self):
  #   fn = os.path.join(os.path.dirname(__file__), 'test', 'test1.jsonc')
  #   obj = LoadSchema(fn)
  #   (_,genc,_) = ProcessSchema(obj)

  def test_genEnums(self):
    fn = os.path.join(os.path.dirname(__file__), 'test_data', 'test1.yaml')
    obj = LoadSchema(fn)
    genOrder: str = ComputeRequiredDeclarationOrder(obj)
    processedSchema = ProcessSchema(obj, genOrder)
    processedSchemaStr = pprint.pformat(processedSchema,indent=2)
    processedSchemaStrRef = """{ 'enums': [ { 'fields': ['RomCom', 'Horror', 'ScienceFiction', 'Vegetables'],
               'name': 'MovieType'},
             { 'fields': [ 'SaltAndPepper',
                           'CreamAndChives',
                           'Paprika',
                           'Barbecue'],
               'name': 'CrispType'}],
  'rootName': 'VsolMessages',
  'structs': [ { 'fields': { 'movies': 'vector<MovieType>',
                             'someInts2': 'vector<int32>',
                             'someStrings': 'vector<string>'},
                 'name': 'A'},
               { 'fields': {'someAs': 'vector<A>', 'someInts': 'vector<int32>'},
                 'name': 'B'},
               { 'fields': {'ddd': 'vector<string>', 'someBs': 'vector<B>'},
                 'name': 'C'}]}"""

    self.assertEqual(processedSchemaStrRef,processedSchemaStr)

  def test_GenerateTypeScriptEnums(self):
    fn = os.path.join(os.path.dirname(__file__), 'test_data', 'test1.yaml')
    tdico = GetTemplatingDictFromSchemaFilename(fn)
    template = Template("""  // end of generic methods
{% for enum in enums%}  export enum {{enum['name']}} {
{% for key in enum['fields']%}    {{key}},
{%endfor%}  };

{%endfor%}""")
    renderedCode = template.render(**tdico)
    renderedCodeRef = """  // end of generic methods
  export enum MovieType {
    RomCom,
    Horror,
    ScienceFiction,
    Vegetables,
  };

  export enum CrispType {
    SaltAndPepper,
    CreamAndChives,
    Paprika,
    Barbecue,
  };

"""
    self.assertEqual(renderedCodeRef,renderedCode)


  def test_GenerateTypeScriptHandlerInterface(self):
    pass

  def test_GenerateCppHandlerInterface(self):
    pass

  def test_GenerateTypeScriptDispatcher(self):
    pass

  def test_GenerateCppDispatcher(self):
    pass

# def test(self):
#   s = 'hello world'
#   self.assertEqual(s.split(), ['hello', 'world'])
#   # check that s.split fails when the separator is not a string
#   with self.assertRaises(TypeError):
#   s.split(2)

if __name__ == '__main__':
  unittest.main()

