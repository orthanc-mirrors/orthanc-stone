from stonegentool import \
EatToken,SplitListOfTypes,ParseTemplateType,LoadSchema,CheckSchemaSchema,ProcessSchema
import unittest
import os
import re

def RemoveDateTimeLine(s : str):
  # regex are non-multiline by default, and $ does NOT match the end of the line
  s2 = re.sub(r"^// autogenerated by stonegentool on .*\n","",s)
  return s2

class TestStonegentool(unittest.TestCase):
  def test_EatToken_empty(self):
    c = r""
    a,b = EatToken(c)
    self.assertEqual(a,r"")
    self.assertEqual(b,r"")

  def test_EatToken_simpleNonTemplate(self):
    c = r"int32"
    a,b = EatToken(c)
    self.assertEqual(a,r"int32")
    self.assertEqual(b,r"")

  def test_EatToken_simpleTemplate(self):
    c = r"vector<string>"
    a,b = EatToken(c)
    self.assertEqual(a,r"vector<string>")
    self.assertEqual(b,r"")

  def test_EatToken_complexTemplate(self):
    c = r"vector<map<int64,string>>,vector<map<int32,string>>"
    a,b = EatToken(c)
    self.assertEqual(a,r"vector<map<int64,string>>")
    self.assertEqual(b,r"vector<map<int32,string>>")

  def test_EatToken_complexTemplates(self):
    c = r"vector<map<vector<string>,map<int32,string>>>,map<int32,string>,map<map<int32,string>,string>"
    a,b = EatToken(c)
    self.assertEqual(a,r"vector<map<vector<string>,map<int32,string>>>")
    self.assertEqual(b,r"map<int32,string>,map<map<int32,string>,string>")
    a,b = EatToken(b)
    self.assertEqual(a,r"map<int32,string>")
    self.assertEqual(b,r"map<map<int32,string>,string>")

  def test_SplitListOfTypes(self):
    c = r"vector<map<vector<string>,map<int32,string>>>,map<int32,string>,map<map<int32,string>,string>"
    lot = SplitListOfTypes(c)
    self.assertEqual(3,len(lot))
    self.assertEqual("vector<map<vector<string>,map<int32,string>>>",lot[0])
    self.assertEqual("map<int32,string>",lot[1])
    self.assertEqual("map<map<int32,string>,string>",lot[2])

  def test_SplitListOfTypes_bogus(self):
    c = r"vector<map<vector<string>,map<int32,string>>,map<int32,string>,map<map<int32,string>,string"
    self.assertRaises(Exception,SplitListOfTypes,c) # the argument c must be passed to assertRaises, not as a normal call of SplitListOfTypes
    
  def test_ParseTemplateType_true(self):
    c = "map<vector<map<int,vector<string>>>,map<vector<int>,vector<string>>>"
    (ok,a,b) = ParseTemplateType(c)
    self.assertEqual(ok,True)
    self.assertEqual(a,"map")
    self.assertEqual(b,["vector<map<int,vector<string>>>","map<vector<int>,vector<string>>"])

    (ok2,a2,b2) = ParseTemplateType(b[0])
    self.assertEqual(ok2,True)
    self.assertEqual(a2,"vector")
    self.assertEqual(b2,["map<int,vector<string>>"])

    (ok3,a3,b3) = ParseTemplateType(b[1])
    self.assertEqual(ok3,True)
    self.assertEqual(a3,"map")
    self.assertEqual(b3,["vector<int>","vector<string>"])

    (ok4,a4,b4) = ParseTemplateType(b2[0])
    self.assertEqual(ok4,True)
    self.assertEqual(a4,"map")
    self.assertEqual(b4,["int","vector<string>"])
    
  def test_ParseSchema(self):
    fn = os.path.join(os.path.dirname(__file__), 'test', 'test1.jsonc')
    obj = LoadSchema(fn)
    # we're happy if it does not crash
    CheckSchemaSchema(obj)

  def test_ParseSchema_bogus_json(self):
    fn = os.path.join(os.path.dirname(__file__), 'test', 'test1_bogus_json.jsonc')
    self.assertRaises(Exception,LoadSchema,fn)

  def test_ParseSchema_bogus_schema(self):
    fn = os.path.join(os.path.dirname(__file__), 'test', 'test1_bogus_schema.jsonc')
    obj = LoadSchema(fn)
    self.assertRaises(Exception,CheckSchemaSchema,obj) 

  def test_GenOrderQueue(self):
    fn = os.path.join(os.path.dirname(__file__), 'test', 'test1.jsonc')
    obj = LoadSchema(fn)
    genOrderQueue:str
    _, _, genOrderQueue = ProcessSchema(obj)
    self.assertEqual(3,len(genOrderQueue))
    self.assertEqual("A",genOrderQueue[0])
    self.assertEqual("B",genOrderQueue[1])
    self.assertEqual("C",genOrderQueue[2])

  def test_GenerateTypeScriptEnumeration(self):
    fn = os.path.join(os.path.dirname(__file__), 'test', 'test1.jsonc')
    obj = LoadSchema(fn)
    (_,outputStreams,_) = ProcessSchema(obj)

    tsRef = """// autogenerated by stonegentool on Fri Feb 15 07:36:51 2019
enum MovieType
{
    Romcom,
    Horror,
    ScienceFiction,
    Vegetables
};

class A
{
    public Array<string> someStrings;
    public Array<number> someInts2;
};

class B
{
    public Array<A> someAs;
    public Array<number> someInts;
};

class C
{
    public Array<B> someBs;
    public Array<D> ddd;
};

"""
    tsRef = RemoveDateTimeLine(tsRef)
    tsActual = RemoveDateTimeLine(outputStreams['ts'].getvalue())

    self.assertEqual(tsActual,tsRef)
  
    cppRef="""// autogenerated by stonegentool on Fri Feb 15 07:36:51 2019
#include <cstdint>
#include <string>
#include <vector>
#include <map>
enum MovieType
{
    Romcom,
    Horror,
    ScienceFiction,
    Vegetables
};

struct A
{
    std::vector<string> someStrings;
    std::vector<int32_t> someInts2;
};

struct B
{
    std::vector<A> someAs;
    std::vector<int32_t> someInts;
};

struct C
{
    std::vector<B> someBs;
    std::vector<D> ddd;
};

"""  
    cppRef = RemoveDateTimeLine(cppRef)
    cppActual = RemoveDateTimeLine(outputStreams['cpp'].getvalue())

    self.assertEqual(cppActual,cppRef)
    pass

  def test_GenerateCppEnumeration(self):
    pass

  def test_GenerateTypeScriptClasses(self):
    pass

  def test_GenerateCppClasses(self):
    pass

  def test_GenerateTypeScriptHandlerInterface(self):
    pass

  def test_GenerateCppHandlerInterface(self):
    pass

  def test_GenerateTypeScriptDispatcher(self):
    pass

  def test_GenerateCppDispatcher(self):
    pass

# def test(self):
#   s = 'hello world'
#   self.assertEqual(s.split(), ['hello', 'world'])
#   # check that s.split fails when the separator is not a string
#   with self.assertRaises(TypeError):
#   s.split(2)

if __name__ == '__main__':
  unittest.main()
